# 블록 필터링 v1.1 - 복잡한 Jackson 인터페이스 방식

## 📋 개요

**심플한 어노테이션 기반 블록 필터링**: `@BlockWord` 어노테이션을 필드에 직접 적용하여 Jackson 직렬화 시점에서 차단된 사용자의 컨텐츠를 대체 메시지로 변경하는 방식

## 🎯 핵심 아이디어

### 기본 원칙
- **필드 레벨 제어**: 응답 객체 구조는 그대로, 필드별로 블록 필터링 적용
- **대체 메시지 방식**: 차단된 사용자 컨텐츠를 완전히 제거하지 않고 지정된 메시지로 교체
- **Jackson 직렬화 활용**: JSON 변환 시점에서 자동으로 필터링 처리
- **최소한의 변경**: 기존 코드 구조를 최대한 유지하면서 블록 기능 추가

## 🏗️ 설계 상세

### 1. 응답 구조 유지
```java
// ReviewListResponse - 기존 구조 그대로 유지
public record ReviewListResponse(
    Long totalCount,
    List<ReviewInfo> reviewList  // 구조 변경 없음
) {
    public static ReviewListResponse of(Long totalCount, List<ReviewInfo> reviewList) {
        return new ReviewListResponse(totalCount, reviewList);
    }
}
```

### 2. 필드 레벨 블록 필터링
```java
// ReviewInfo - 특정 필드에만 @BlockWord 적용
@Builder
public record ReviewInfo(
    Long reviewId,
    
    @BlockWord  // 차단된 사용자의 리뷰 내용 필터링
    String reviewContent,
    
    String reviewImageUrl,
    // ... 기타 필드들 (블록 필터링 불필요)
    
    UserInfo userInfo,  // 내부에서 닉네임 필터링
    // ... 나머지 필드들
) {
}
```

### 3. 사용자 정보 블록 필터링
```java
// UserInfo - 닉네임에 대체 메시지 적용
public record UserInfo(
    Long userId,  // userId는 그대로 유지 (차단 관계 판단용)
    
    @BlockWord(대체메시지 = "차단된 사용자")  // 커스텀 대체 메시지
    String nickName,
    
    String userProfileImage  // 프로필 이미지는 유지
) {
    public static UserInfo of(Long userId, String nickName, String userProfileImage) {
        return new UserInfo(userId, nickName, userProfileImage);
    }
}
```

## 🔧 @BlockWord 어노테이션 설계

### 어노테이션 정의
```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface BlockWord {
    /**
     * 차단된 사용자 컨텐츠 대체 메시지
     * 기본값: 빈 문자열 (컨텐츠 완전 숨김)
     */
    String 대체메시지() default "";
    
    /**
     * 차단 판단 기준이 되는 사용자 ID 필드명
     * 기본값: 같은 객체 내 "userId" 필드 사용
     */
    String userIdField() default "userId";
}
```

### 사용 예시
```java
// 케이스 1: 컨텐츠 완전 숨김
@BlockWord
String reviewContent;  // → ""

// 케이스 2: 대체 메시지로 교체
@BlockWord(대체메시지 = "차단된 사용자")
String nickName;  // → "차단된 사용자"

// 케이스 3: 다른 필드의 userId 참조
@BlockWord(userIdField = "authorId", 대체메시지 = "차단된 댓글")
String commentContent;
```

## 🎨 처리 흐름

### 1. 정상 사용자 컨텐츠
```json
{
  "reviewContent": "정말 맛있는 위스키입니다!",
  "userInfo": {
    "userId": 123,
    "nickName": "위스키러버",
    "userProfileImage": "profile.jpg"
  }
}
```

### 2. 차단된 사용자 컨텐츠 (필터링 후)
```json
{
  "reviewContent": "",  // @BlockWord로 빈 문자열 처리
  "userInfo": {
    "userId": 456,  // userId는 유지 (시스템에서 사용)
    "nickName": "차단된 사용자",  // 대체 메시지로 교체
    "userProfileImage": "profile.jpg"  // 프로필 이미지는 유지
  }
}
```

## 🔍 동작 원리

### Jackson 커스텀 시리얼라이저 처리 과정

1. **필드 스캔**: `@BlockWord` 어노테이션이 붙은 필드 감지
2. **사용자 ID 획득**: 현재 요청 사용자와 컨텐츠 작성자 ID 확인
3. **차단 관계 검사**: `BlockService`를 통해 차단 관계 확인 (캐시 활용)
4. **조건부 대체**: 차단된 경우에만 지정된 대체 메시지로 변경
5. **JSON 출력**: 필터링된 결과를 JSON으로 직렬화

## 🚀 장점

### 1. 심플함
- **최소한의 코드 변경**: 기존 DTO에 어노테이션만 추가
- **직관적**: 어떤 필드가 필터링되는지 한눈에 파악 가능
- **설정 불필요**: 복잡한 인터페이스나 설정 클래스 불필요

### 2. 유연성
- **필드별 제어**: 각 필드마다 다른 대체 메시지 설정 가능
- **선택적 적용**: 필요한 필드에만 선택적으로 적용
- **커스터마이징**: userIdField로 다양한 구조에 대응

### 3. 성능
- **Jackson 레벨 처리**: 직렬화 시점에만 실행으로 효율적
- **캐시 활용**: 기존 BlockService의 캐싱 메커니즘 그대로 활용
- **조건부 실행**: 차단 관계가 있을 때만 처리

### 4. 유지보수성
- **관심사 분리**: 비즈니스 로직과 블록 필터링 완전 분리
- **기존 구조 유지**: 응답 객체나 컨트롤러 구조 변경 없음
- **확장 용이**: 새로운 DTO에 쉽게 적용 가능

## 🛠️ 구현 범위

### Phase 1: 핵심 구성요소
- `@BlockWord` 어노테이션 정의
- Jackson 커스텀 시리얼라이저 구현
- 현재 사용자 컨텍스트 획득 로직

### Phase 2: DTO 적용
- `ReviewInfo`에 `reviewContent` 필드 블록 필터링 적용
- `UserInfo`에 `nickName` 필드 블록 필터링 적용

### Phase 3: 기존 코드 정리
- 컨트롤러의 `@BlockFilter` 어노테이션 제거
- AOP 기반 블록 필터링 코드 제거

## 🎯 예상 결과

### 개발자 경험
- **간단한 적용**: `@BlockWord` 어노테이션 하나로 블록 필터링 완성
- **명확한 의도**: 코드만 봐도 어떤 필드가 블록 대상인지 즉시 파악
- **디버깅 용이**: JSON 응답에서 바로 필터링 결과 확인 가능

### 사용자 경험
- **자연스러운 차단**: 차단된 사용자 컨텐츠가 자연스럽게 대체됨
- **정보 유지**: 사용자 ID 등 필요한 메타데이터는 그대로 유지
- **일관성**: 모든 API에서 동일한 방식으로 차단 처리

## 📝 결론

`@BlockWord` 어노테이션 기반 블록 필터링은 복잡한 설정 없이도 강력하고 유연한 블록 기능을 제공합니다. 기존 코드 구조를 최대한 유지하면서도 세밀한 제어가 가능한 우아한 솔루션입니다.