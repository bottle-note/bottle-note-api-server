# 블록 필터링 v1.3 - 중첩 객체 지원 @BlockWord 방식

## 📋 개요

**@BlockWord 어노테이션 기반 블록 필터링**: JSON 직렬화 시점에서 차단된 사용자 컨텐츠를 자동으로 대체 메시지로 변경

## 🎯 핵심 설계

### @BlockWord 어노테이션 정의
```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface BlockWord {
    /**
     * 차단된 사용자 컨텐츠 대체 메시지
     * 기본값: "차단된 사용자의 글입니다"
     */
    String value() default "차단된 사용자의 글입니다";
    
    /**
     * 차단 판단 기준이 되는 사용자 ID 경로
     * 기본값: 같은 객체 내 "userId" 필드
     * 중첩 객체: "userInfo.userId" 형태 지원
     */
    String userIdPath() default "userId";
}
```

### 사용 예시

#### 1. 기본 대체 메시지 사용
```java
@BlockWord(userIdPath = "userInfo.userId")
String reviewContent;  // → "차단된 사용자의 글입니다"
```

#### 2. 커스텀 대체 메시지
```java
@BlockWord(value = "차단된 사용자", userIdPath = "userInfo.userId")  
String nickName;  // → "차단된 사용자"
```

#### 3. 중첩 객체에서 userId 참조
```java
// ReviewInfo 구조
public record ReviewInfo(
    @BlockWord(userIdPath = "userInfo.userId")  // 내부 객체의 userId 참조
    String reviewContent,
    
    UserInfo userInfo  // userId를 포함한 중첩 객체
) {}

public record UserInfo(
    Long userId,  // 차단 판단 기준
    
    @BlockWord(userIdPath = "userId")  // 같은 객체 내 userId 참조
    String nickName
) {}
```

## 🔧 동작 원리

### 1. 경로 기반 userId 획득
- **단순 경로**: `"userId"` → 같은 객체 내 userId 필드
- **중첩 경로**: `"userInfo.userId"` → userInfo 객체 내부의 userId 필드
- **리플렉션 활용**: 런타임에 지정된 경로로 userId 값 추출

### 2. 차단 관계 검사 흐름
```
1. @BlockWord 필드 감지
2. userIdPath로 작성자 userId 추출
3. 현재 요청 사용자 ID 획득 (SecurityContext)
4. BlockService.isBlocked(currentUserId, authorId) 호출
5. 차단된 경우 → 대체 메시지로 변경
6. 정상인 경우 → 원본 값 유지
```

## 📝 적용 예시

### ReviewInfo 적용
```java
@Builder
public record ReviewInfo(
    Long reviewId,
    
    // 리뷰 내용 - userInfo 내부의 userId로 차단 판단
    @BlockWord(userIdPath = "userInfo.userId")
    String reviewContent,
    
    String reviewImageUrl,
    LocalDateTime createAt,
    
    // 사용자 정보 - 내부에서 nickName 필터링
    UserInfo userInfo,
    
    Boolean isMyReview,
    // ... 기타 필드들
) {}
```

### UserInfo 적용
```java
public record UserInfo(
    Long userId,  // 차단 판단 기준
    
    // 닉네임 - 같은 객체 내 userId로 차단 판단
    @BlockWord(value = "차단된 사용자", userIdPath = "userId")
    String nickName,
    
    String userProfileImage
) {
    public static UserInfo of(Long userId, String nickName, String userProfileImage) {
        return new UserInfo(userId, nickName, userProfileImage);
    }
}
```

## 🎨 처리 결과

### 정상 사용자 응답
```json
{
  "reviewContent": "정말 맛있는 위스키입니다!",
  "userInfo": {
    "userId": 123,
    "nickName": "위스키러버",
    "userProfileImage": "profile.jpg"
  }
}
```

### 차단된 사용자 응답 (필터링 후)
```json
{
  "reviewContent": "차단된 사용자의 글입니다",
  "userInfo": {
    "userId": 456,  // userId는 유지 (시스템 동작용)
    "nickName": "차단된 사용자",
    "userProfileImage": "profile.jpg"
  }
}
```

## 🚀 주요 특징

### 1. 유연한 경로 지정
- **단순 구조**: `userIdPath = "userId"`
- **중첩 구조**: `userIdPath = "userInfo.userId"`
- **깊은 중첩**: `userIdPath = "author.profile.userId"` (필요시 확장)

### 2. 기본값 제공
- **대체 메시지**: 지정하지 않으면 "차단된 사용자의 글입니다"
- **경로**: 지정하지 않으면 같은 객체 내 "userId" 필드 사용

### 3. 성능 최적화
- **캐시 활용**: BlockService의 기존 캐싱 메커니즘 활용
- **조건부 실행**: 차단 관계가 있을 때만 대체 처리
- **직렬화 시점**: JSON 변환할 때만 실행

## 🛠️ 구현 고려사항

### 1. 경로 파싱
- dot notation 파싱 로직 구현
- 중첩 객체 접근을 위한 리플렉션 활용
- 경로가 유효하지 않을 때 예외 처리

### 2. 현재 사용자 컨텍스트
- SecurityContextUtil을 통한 현재 사용자 ID 획득
- 로그인하지 않은 사용자 처리 (필터링 스킵)

### 3. Jackson 커스텀 시리얼라이저
- @BlockWord 어노테이션 스캔
- 필드별 조건부 값 변경
- 원본 객체 수정 없이 직렬화 시에만 변경

## 📋 장점

- **직관적**: 어노테이션만 봐도 어떤 필드가 어떻게 필터링되는지 명확
- **유연함**: 다양한 객체 구조에 대응 가능한 경로 지정 방식
- **최소 변경**: 기존 DTO 구조 변경 없이 어노테이션만 추가
- **성능**: 필요할 때만 실행되는 효율적인 구조