# 블록 필터링 v1.0 - AOP 방식

## 📋 개요

**AOP 기반 컨트롤러 레벨 블록 필터링**: `@BlockFilter` 어노테이션을 컨트롤러 메서드에 적용하여 차단된 사용자의 컨텐츠를 "블러" 처리하는 방식

## 🎯 @BlockFilter 어노테이션

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface BlockFilter {
    /**
     * 응답 객체에서 사용자 ID를 추출할 필드명
     */
    String userField() default "authorId";
    
    /**
     * 블러 처리할 필드명 배열
     */
    String[] blurFields() default {
        "content", "reviewContent", "title", 
        "authorNickname", "nickname", 
        "authorProfileImage", "profileImage"
    };
}
```

## 📝 사용 예시

### 컨트롤러 적용
```java
@RestController
public class ReviewController {
    
    @BlockFilter(userField = "authorId")
    @GetMapping("/{alcoholId}")
    public ResponseEntity<?> getReviews(@PathVariable Long alcoholId) {
        // 비즈니스 로직 실행
        return GlobalResponse.ok(reviewService.getReviews(alcoholId));
    }
}
```

## 🔧 동작 원리

### 1. AOP Aspect 처리 흐름
```java
@Around("@annotation(blockFilter)")
public Object applyBlockFilter(ProceedingJoinPoint joinPoint, BlockFilter blockFilter) {
    // 1. 원본 메서드 실행
    Object result = joinPoint.proceed();
    
    // 2. 현재 사용자 ID 추출
    Long currentUserId = extractCurrentUserId();
    
    // 3. 차단된 사용자 목록 조회
    Set<Long> blockedUserIds = blockService.getBlockedUserIds(currentUserId);
    
    // 4. 응답 데이터에 블러 처리 적용
    return applyBlurFilter(result, blockedUserIds, blockFilter);
}
```

### 2. 블러 처리 과정
1. **ResponseEntity → GlobalResponse → data 순으로 탐색**
2. **데이터 타입 확인**: List 또는 단일 객체
3. **각 항목별로 사용자 ID 추출** (`userField` 사용)
4. **차단 대상인지 확인** (blockedUserIds에 포함 여부)
5. **차단된 경우 객체 복제 후 필드 마스킹**

### 3. 필드 마스킹 규칙
```java
// 텍스트 필드: "차단된 사용자의 글입니다"
reviewContent → "차단된 사용자의 글입니다"
authorNickname → "차단된 사용자의 글입니다"

// 이미지/URL 필드: null 처리
authorProfileImage → null
imageUrl → null
```

## 🎨 처리 결과

### 정상 사용자 응답
```json
{
  "success": true,
  "data": {
    "reviewList": [
      {
        "authorId": 123,
        "reviewContent": "정말 맛있는 위스키입니다!",
        "authorNickname": "위스키러버",
        "authorProfileImage": "profile.jpg"
      }
    ]
  }
}
```

### 차단된 사용자 응답 (블러 처리 후)
```json
{
  "success": true,
  "data": {
    "reviewList": [
      {
        "authorId": 456,
        "reviewContent": "차단된 사용자의 글입니다",
        "authorNickname": "차단된 사용자의 글입니다", 
        "authorProfileImage": null
      }
    ]
  }
}
```

## 🛠️ 구현 구조

### 핵심 파일들
- `annotation/BlockFilter.java` - 어노테이션 정의
- `aspect/BlockFilterAspect.java` - AOP 처리 로직
- `service/BlockService.java` - 차단 관계 조회
- `controller/BlockTestController.java` - 테스트 컨트롤러

### 주요 메서드
1. **extractCurrentUserId()**: 현재 사용자 ID 추출 (테스트용 고정값)
2. **applyBlurFilter()**: 응답 데이터 타입별 블러 처리 분기
3. **blurItemIfBlocked()**: 개별 항목 차단 여부 확인 및 처리
4. **applyBlurToItem()**: Jackson 깊은 복사 후 필드 마스킹
5. **maskField()**: 필드 타입에 따른 마스킹 값 설정

## 🚧 한계점

### 1. 복잡한 처리 과정
- **ResponseEntity → GlobalResponse → data 구조 의존성**
- **리플렉션 기반 필드 접근으로 인한 성능 이슈**
- **Jackson 깊은 복사로 인한 메모리 사용량 증가**

### 2. 컨트롤러 결합도
- **각 컨트롤러 메서드마다 어노테이션 추가 필요**
- **userField 설정이 응답 구조에 의존적**
- **새로운 응답 구조 추가 시 blurFields 재설정 필요**

### 3. 유지보수 어려움
- **AOP 처리 과정이 복잡하여 디버깅 어려움**
- **응답 구조 변경 시 필터링 로직도 함께 수정 필요**
- **테스트용 고정 사용자 ID 등 임시 구현 존재**

### 4. 확장성 제한
- **특정 응답 구조(GlobalResponse)에만 동작**
- **중첩 객체 내부 필드 처리 복잡**
- **다양한 블러 처리 방식 적용 어려움**

## 📝 결론

AOP 방식은 컨트롤러 레벨에서 블록 필터링을 처리하지만, 복잡한 구조와 높은 결합도로 인해 유지보수가 어려운 방식입니다. 특히 응답 구조에 대한 의존성이 높고, 성능상 오버헤드가 존재합니다.