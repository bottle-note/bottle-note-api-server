# 블록 필터링 v1.5 - Jackson 시리얼라이저 구현

## 📋 개요

**실제 구현된 @BlockWord 방식**: Jackson ContextualSerializer를 활용하여 직렬화 시점에서 차단된 사용자 컨텐츠를 자동으로 대체하는 구현

## 🎯 구현 구성요소

### 1. @BlockWord 어노테이션
```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface BlockWord {
    String value() default "차단된 사용자의 글입니다";
    String userIdPath() default "userId";
}
```

### 2. BlockWordSerializer
```java
@Component
public class BlockWordSerializer extends JsonSerializer<String> implements ContextualSerializer {
    
    @Override
    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) {
        // 1. 현재 사용자 ID 획득 (SecurityContextUtil)
        // 2. 비로그인 사용자는 필터링 스킵
        // 3. userIdPath로 작성자 ID 추출 (리플렉션)
        // 4. BlockService.isBlocked() 호출
        // 5. 차단된 경우 대체 메시지로 변경
    }
    
    @Override
    public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) {
        // @BlockWord 어노테이션 감지하여 컨텍스트별 시리얼라이저 생성
    }
}
```

### 3. BlockWordConfig
```java
@Configuration
public class BlockWordConfig {
    
    @PostConstruct
    public void configureObjectMapper() {
        SimpleModule blockWordModule = new SimpleModule("BlockWordModule");
        blockWordModule.addSerializer(String.class, blockWordSerializer);
        objectMapper.registerModule(blockWordModule);
    }
}
```

## 🔧 동작 과정

### 1. 시리얼라이저 등록
- ObjectMapper에 BlockWordSerializer를 String 타입에 대해 등록
- @BlockWord 어노테이션이 있는 필드에서만 동작하도록 ContextualSerializer 활용

### 2. 직렬화 시점 처리
```java
// JSON 직렬화 시점에서 자동 호출
serialize(String value, JsonGenerator gen, SerializerProvider serializers) {
    
    // 현재 사용자 ID 획득
    Long currentUserId = SecurityContextUtil.getUserIdByContext().orElse(null);
    if (currentUserId == null) {
        gen.writeString(value);  // 비로그인 → 원본 반환
        return;
    }
    
    // 작성자 ID 추출 (리플렉션)
    Object currentObject = gen.getCurrentValue();
    Long authorId = extractUserIdByPath(currentObject, userIdPath);
    
    // 차단 관계 확인
    boolean isBlocked = blockService.isBlocked(currentUserId, authorId);
    if (isBlocked) {
        gen.writeString(대체메시지);  // 차단됨 → 대체 메시지
    } else {
        gen.writeString(value);     // 정상 → 원본 값
    }
}
```

### 3. 경로 기반 userId 추출
```java
private Long extractUserIdByPath(Object object, String userIdPath) {
    String[] pathParts = userIdPath.split("\\.");
    Object currentObject = object;
    
    // dot notation 경로 탐색
    for (String part : pathParts) {
        Field field = findField(currentObject.getClass(), part);
        field.setAccessible(true);
        currentObject = field.get(currentObject);
    }
    
    return (Long) currentObject;
}
```

## 📝 사용 예시

### ReviewInfo 적용
```java
@Builder
public record ReviewInfo(
    Long reviewId,
    
    @BlockWord(userIdPath = "userInfo.userId")
    String reviewContent,
    
    UserInfo userInfo
) {}
```

### UserInfo 적용
```java
public record UserInfo(
    Long userId,
    
    @BlockWord(value = "차단된 사용자", userIdPath = "userId")  
    String nickName,
    
    String userProfileImage
) {}
```

## 🎨 처리 결과

### 정상 사용자
```json
{
  "reviewContent": "정말 맛있는 위스키입니다!",
  "userInfo": {
    "userId": 123,
    "nickName": "위스키러버"
  }
}
```

### 차단된 사용자
```json
{
  "reviewContent": "차단된 사용자의 글입니다",
  "userInfo": {
    "userId": 456,
    "nickName": "차단된 사용자"
  }
}
```

## 🛠️ 구현 특징

### 1. ContextualSerializer 활용
- BeanProperty에서 @BlockWord 어노테이션 추출
- 어노테이션별로 독립적인 시리얼라이저 인스턴스 생성
- 필드별 개별 설정 적용

### 2. 리플렉션 기반 경로 탐색
- dot notation 지원: "userInfo.userId"
- 클래스 상속 계층 고려한 필드 검색
- 실패 시 원본 값 반환으로 안정성 확보

### 3. 현재 사용자 컨텍스트
- SecurityContextUtil.getUserIdByContext() 활용
- Optional 반환값 처리로 비로그인 사용자 고려
- 예외 상황에서 원본 값 보존

### 4. 에러 핸들링
- 각 단계별 try-catch로 안정성 확보
- 실패 시 로그 기록 후 원본 값 반환
- 운영 중 장애 방지를 위한 방어적 프로그래밍

## 📋 구현 파일 구조

```
common/block/
├── annotation/
│   └── BlockWord.java           # 어노테이션 정의
├── serializer/
│   └── BlockWordSerializer.java # Jackson 커스텀 시리얼라이저
├── config/
│   └── BlockWordConfig.java     # ObjectMapper 설정
└── service/
    └── BlockService.java        # 차단 관계 조회 (기존)
```

## 📝 결론

Jackson의 ContextualSerializer를 활용한 방식으로 필드 레벨에서 세밀한 블록 필터링을 구현했습니다. AOP 방식의 복잡성을 제거하고 직렬화 시점에서 자연스럽게 처리되도록 구현했습니다.