# Facade 계층 테스트 커버리지

## 0. 왜 Facade 테스트인가

### Facade의 역할

Facade는 DDD 아키텍처에서 도메인 간 조율자 역할을 수행합니다:
- 여러 Service를 조합하여 복합적인 비즈니스 로직 구현
- 도메인 간 경계를 넘나드는 트랜잭션 관리
- Controller와 Service 사이의 계약 정의

### Facade 테스트가 중요한 이유

**도메인 간 계약의 검증**

Facade는 여러 도메인 Service를 조합합니다. Facade 테스트 없이는 이 조합이 올바른지 알 수 없습니다.
- ReviewFacade가 UserFacade를 올바르게 호출하는가?
- 트랜잭션 경계가 정확한가?
- 예외 전파가 의도대로 동작하는가?

**실제 버그가 숨어있는 곳**

단순해 보이는 Facade 코드에도 버그가 있습니다:

```java
public void requestBlockReview(Long reviewId) {
    reviewRepository.findById(reviewId).ifPresent(Review::blockReview);
}
```

이 코드는 존재하지 않는 리뷰를 차단하려 해도 조용히 무시합니다.
이것이 의도인가? 버그인가? 테스트 없이는 알 수 없습니다.

**리팩토링의 안전망**

Service 내부를 수정해도 Facade 테스트가 통과하면 외부 계약이 보존됨을 보장합니다.
이는 Service 리팩토링에 대한 자신감을 제공합니다.

**신입 개발자를 위한 문서**

"이 Facade는 어떻게 사용하나요?"
테스트 코드를 보면 모든 사용 시나리오를 이해할 수 있습니다.

## 1. 현황 분석

### 전체 Facade 목록

| Facade | 위치 | 메서드 수 | 테스트 상태 |
|--------|------|-----------|------------|
| DefaultUserFacade | bottlenote-mono/src/main/java/app/bottlenote/user/service/ | 3 | ✅ 완료 |
| DefaultReviewFacade | bottlenote-mono/src/main/java/app/bottlenote/review/service/ | 5 | ✅ 완료 |
| DefaultAlcoholFacade | bottlenote-mono/src/main/java/app/bottlenote/alcohols/service/ | 5 | ✅ 완료 |
| FollowService | bottlenote-mono/src/main/java/app/bottlenote/user/service/ | 4 | ✅ 완료 (리팩토링 후) |

### 커버리지 현황

- 전체 Facade: 4개
- 단위 테스트 대상: 4개 (모두 포함)
- 테스트 존재: 4개 (모두 완료)
- **이전 커버리지: 0%**
- **현재 커버리지: 100%** (모든 Facade 테스트 완료)
- **목표 커버리지: 85%** ✅ 달성

### FollowService 리팩토링 완료

**이전 문제:**
- FollowRepository가 `JpaRepository<Follow, Long>` 직접 상속
- JpaRepository 약 20개 기본 메서드로 InMemory 구현 불가
- 단위 테스트 작성 불가능

**리팩토링 솔루션:**
1. **순수 인터페이스 추출**
   - `domain/FollowRepository`: 순수 인터페이스 (@DomainRepository)
   - 필수 메서드 5개만 정의

2. **JPA 구현체 분리**
   - `repository/SpringDataJpaFollowRepository`: JpaRepository 상속 (내부 인터페이스)
   - `repository/JpaFollowRepositoryImpl`: 실제 구현체 (@JpaRepositoryImpl)
   - 메서드 위임 패턴으로 구현

3. **테스트 인프라**
   - `fixture/InMemoryFollowRepository`: HashMap 기반 InMemory 구현
   - `service/FollowServiceTest`: 단위 테스트 7개 작성

**결과:**
- FollowService 단위 테스트 가능
- 다른 Repository들과 일관된 아키텍처
- 테스트 커버리지 향상

### 목표 설정 근거

**왜 85%인가?**
- 업계 표준: 핵심 계층은 85-95% 권장 (Google: 90% = exemplary)
- Facade는 도메인 간 계약의 핵심이므로 높은 커버리지 필요
- 하지만 일부 예외 경로는 통합 테스트로 대체 가능
- 100%는 과도한 목표 (시간 대비 효율 감소, Martin Fowler 경고)

자세한 근거는 `0-개요.md`의 "커버리지 표준 및 근거" 참조

### 왜 0%인가?

Facade 계층은 프로젝트에서 비교적 최근에 도입된 패턴입니다.
초기에는 Service 테스트에 집중하면서 Facade 테스트가 누락되었습니다.
하지만 Facade는 도메인 간 계약의 핵심이므로 테스트가 필수적입니다.

## 2. 우선순위

### P0: 최우선 작성 대상

**DefaultReviewFacade**
- 이유: 차단 로직에 잠재적 버그 존재 (ifPresent 사용)
- 영향도: Review 도메인 전체에 영향
- 복잡도: 중간 (5개 메서드)

**DefaultUserFacade**
- 이유: 전체 도메인에서 사용되는 핵심 Facade
- 영향도: 모든 도메인에서 사용자 검증 시 호출
- 복잡도: 낮음 (3개 메서드)

### P1: 중요 작성 대상

**DefaultAlcoholFacade**
- 이유: 주류 정보 조회의 중심
- 영향도: Review, Rating 등 다수 도메인과 연계
- 복잡도: 낮음 (2개 메서드)

**FollowService** ✅
- 완료: 리팩토링을 통해 InMemory 단위 테스트 가능하게 개선
- 테스트 완료: updateFollowStatus 중심으로 7개 시나리오 작성

## 3. 구체적 테스트 시나리오

### DefaultUserFacade

**파일 위치**: `bottlenote-mono/src/main/java/app/bottlenote/user/service/DefaultUserFacade.java`

#### 메서드: existsByUserId

**시나리오 1: 유저가 존재할 때**
- 시나리오: 유저가 존재할 때 true를 반환해야 한다
- 왜: 기본 동작 검증, 다른 도메인에서 의존하는 핵심 기능
- 테스트 방법: 유저 저장 후 existsByUserId 호출

**시나리오 2: 유저가 존재하지 않을 때**
- 시나리오: 유저가 존재하지 않을 때 false를 반환해야 한다
- 왜: 존재하지 않는 경우 처리 검증
- 테스트 방법: 저장하지 않은 ID로 existsByUserId 호출

#### 메서드: isValidUserId

**시나리오 1: 유효한 유저일 때**
- 시나리오: 유효한 유저 ID일 때 예외가 발생하지 않아야 한다
- 왜: 정상 케이스 검증
- 테스트 방법: 유저 저장 후 isValidUserId 호출, 예외 없음 확인

**시나리오 2: 유효하지 않은 유저일 때**
- 시나리오: 유효하지 않은 유저 ID일 때 USER_NOT_FOUND 예외가 발생해야 한다
- 왜: 예외 처리 검증, 잘못된 ID 요청 방어
- 테스트 방법: 존재하지 않는 ID로 호출, UserException 발생 확인

**시나리오 3: null ID일 때**
- 시나리오: null 유저 ID일 때 적절한 예외가 발생해야 한다
- 왜: null 안전성 검증
- 테스트 방법: null로 호출, 예외 발생 확인

#### 메서드: getUserProfileInfo

**시나리오 1: 유저 프로필 조회 성공**
- 시나리오: 유저가 존재할 때 프로필 정보를 정확히 반환해야 한다
- 왜: 정상 케이스 및 데이터 매핑 검증
- 테스트 방법: 유저 저장 후 getUserProfileInfo 호출, 모든 필드 검증

**시나리오 2: 존재하지 않는 유저 조회**
- 시나리오: 존재하지 않는 유저일 때 USER_NOT_FOUND 예외가 발생해야 한다
- 왜: 예외 처리 검증
- 테스트 방법: 존재하지 않는 ID로 호출, 예외 확인

**시나리오 3: 여러 유저의 프로필 구분**
- 시나리오: 서로 다른 유저의 프로필을 정확히 구분해야 한다
- 왜: 데이터 정확성 검증
- 테스트 방법: 여러 유저 저장 후 각각 조회, 올바른 정보 반환 확인

### DefaultReviewFacade

**파일 위치**: `bottlenote-mono/src/main/java/app/bottlenote/review/service/DefaultReviewFacade.java`

#### 메서드: getReviewInfoList

**시나리오 1: 리뷰 목록 조회 성공**
- 시나리오: 술 ID로 리뷰 목록을 조회할 때 정확한 목록을 반환해야 한다
- 왜: 핵심 조회 기능 검증
- 테스트 방법: 리뷰 저장 후 getReviewInfoList 호출, 결과 확인

**시나리오 2: 리뷰가 없을 때**
- 시나리오: 리뷰가 없는 술 ID로 조회할 때 빈 목록을 반환해야 한다
- 왜: 엣지 케이스 검증
- 테스트 방법: 리뷰 없는 술 ID로 호출, 빈 목록 확인

**시나리오 3: 페이징 처리**
- 시나리오: 페이지 크기만큼만 리뷰를 반환해야 한다
- 왜: 페이징 로직 검증
- 테스트 방법: 다수 리뷰 저장 후 pageSize=6 확인

#### 메서드: getAlcoholIdByReviewId

**시나리오 1: 정상 조회**
- 시나리오: 리뷰 ID로 술 ID를 정확히 조회해야 한다
- 왜: 기본 동작 검증
- 테스트 방법: 리뷰 저장 후 getAlcoholIdByReviewId 호출, 술 ID 일치 확인

**시나리오 2: 존재하지 않는 리뷰**
- 시나리오: 존재하지 않는 리뷰 ID일 때 REVIEW_NOT_FOUND 예외가 발생해야 한다
- 왜: 예외 처리 검증
- 테스트 방법: 존재하지 않는 ID로 호출, 예외 확인

**시나리오 3: 여러 리뷰 구분**
- 시나리오: 서로 다른 리뷰는 서로 다른 술 ID를 반환해야 한다
- 왜: 데이터 정확성 검증
- 테스트 방법: 여러 리뷰 저장 후 각각 조회, 올바른 술 ID 확인

#### 메서드: isExistReview

**시나리오 1: 존재하는 리뷰**
- 시나리오: 리뷰가 존재할 때 true를 반환해야 한다
- 왜: 기본 동작 검증
- 테스트 방법: 리뷰 저장 후 isExistReview 호출, true 확인

**시나리오 2: 존재하지 않는 리뷰**
- 시나리오: 리뷰가 존재하지 않을 때 false를 반환해야 한다
- 왜: 존재하지 않는 경우 처리 검증
- 테스트 방법: 저장하지 않은 ID로 호출, false 확인

#### 메서드: requestBlockReview

**시나리오 1: 리뷰 차단 성공**
- 시나리오: 리뷰가 존재할 때 정상적으로 차단해야 한다
- 왜: 핵심 기능 검증
- 테스트 방법: 리뷰 저장 후 requestBlockReview 호출, 차단 상태 확인

**시나리오 2: 존재하지 않는 리뷰 차단 시도 (중요!)**
- 시나리오: 존재하지 않는 리뷰를 차단할 때의 동작을 명확히 해야 한다
- 왜: 현재 ifPresent로 인해 조용히 무시되는데, 이것이 의도인지 확인 필요
- 테스트 방법: 존재하지 않는 ID로 호출, 동작 확인
- 참고: 예외를 던지는 것이 더 명확할 수 있음

**시나리오 3: 이미 차단된 리뷰 재차단**
- 시나리오: 이미 차단된 리뷰를 다시 차단할 때 멱등성을 보장해야 한다
- 왜: 중복 요청 처리 검증
- 테스트 방법: 차단 후 재차단 호출, 여전히 차단 상태 확인

#### 메서드: getReviewInfo

**시나리오 1: 리뷰 상세 조회 성공**
- 시나리오: 리뷰 ID로 상세 정보를 정확히 조회해야 한다
- 왜: 핵심 조회 기능 검증
- 테스트 방법: 리뷰 저장 후 getReviewInfo 호출, 모든 필드 확인

**시나리오 2: 존재하지 않는 리뷰 조회**
- 시나리오: 존재하지 않는 리뷰 ID일 때 적절한 처리를 해야 한다
- 왜: 예외 케이스 검증
- 테스트 방법: 존재하지 않는 ID로 호출, 동작 확인

### DefaultAlcoholFacade

**파일 위치**: `bottlenote-mono/src/main/java/app/bottlenote/alcohols/service/DefaultAlcoholFacade.java`

#### 메서드별 시나리오

**getReviewInfoList**
- 시나리오 1: 술 ID로 리뷰 목록을 조회할 때 정확한 목록을 반환해야 한다
- 시나리오 2: 리뷰가 없을 때 빈 목록을 반환해야 한다
- 시나리오 3: 페이지 크기 제한이 적용되어야 한다

**getAlcoholName**
- 시나리오 1: 술 ID로 술 이름을 정확히 조회해야 한다
- 시나리오 2: 존재하지 않는 술 ID일 때 예외가 발생해야 한다

### FollowService ✅ 리팩토링 완료

**파일 위치**: `bottlenote-mono/src/main/java/app/bottlenote/user/service/FollowService.java`

**리팩토링 개요**:
- JpaRepository 직접 상속 문제를 순수 인터페이스 추출로 해결
- InMemory 구현 가능하도록 아키텍처 개선
- 단위 테스트 작성 완료

#### 메서드: updateFollowStatus

**시나리오 1: 신규 팔로우 생성**
- 시나리오: 새로운 팔로우를 정상적으로 생성할 수 있다
- 왜: 핵심 기능 검증
- 테스트 방법: 유저 저장 후 팔로우 요청, 응답 확인

**시나리오 2: 팔로우 상태 변경**
- 시나리오: 기존 팔로우의 상태를 변경할 수 있다
- 왜: 언팔로우 기능 검증
- 테스트 방법: 팔로우 후 언팔로우 요청, 상태 변경 확인

**시나리오 3: 자기 자신 팔로우 예외**
- 시나리오: 자기 자신을 팔로우하려 하면 CANNOT_FOLLOW_SELF 예외가 발생한다
- 왜: 비즈니스 규칙 검증
- 테스트 방법: 같은 ID로 팔로우 요청, 예외 확인

**시나리오 4: 현재 유저 없음 예외**
- 시나리오: 존재하지 않는 현재 유저일 때 USER_NOT_FOUND 예외가 발생한다
- 왜: 예외 처리 검증
- 테스트 방법: 존재하지 않는 유저 ID로 팔로우 요청, 예외 확인

**시나리오 5: 타겟 유저 없음 예외**
- 시나리오: 존재하지 않는 타겟 유저일 때 FOLLOW_NOT_FOUND 예외가 발생한다
- 왜: 예외 처리 검증
- 테스트 방법: 존재하지 않는 타겟 유저로 팔로우 요청, 예외 확인

**시나리오 6: 중복 팔로우 멱등성**
- 시나리오: 팔로우 후 다시 팔로우하면 상태가 유지된다
- 왜: 멱등성 보장 검증
- 테스트 방법: 팔로우 후 재요청, 상태 유지 확인

## 4. 체크리스트

### DefaultUserFacade

- [ ] existsByUserId - 유저 존재 시 true 반환
- [ ] existsByUserId - 유저 미존재 시 false 반환
- [ ] isValidUserId - 유효한 유저 시 예외 없음
- [ ] isValidUserId - 유효하지 않은 유저 시 USER_NOT_FOUND 예외
- [ ] isValidUserId - null ID 시 예외 발생
- [ ] getUserProfileInfo - 프로필 정확히 반환
- [ ] getUserProfileInfo - 존재하지 않는 유저 시 예외
- [ ] getUserProfileInfo - 여러 유저 구분

### DefaultReviewFacade

- [ ] getReviewInfoList - 리뷰 목록 정확히 조회
- [ ] getReviewInfoList - 리뷰 없을 때 빈 목록
- [ ] getReviewInfoList - 페이징 처리
- [ ] getAlcoholIdByReviewId - 술 ID 정확히 조회
- [ ] getAlcoholIdByReviewId - 존재하지 않는 리뷰 시 예외
- [ ] getAlcoholIdByReviewId - 여러 리뷰 구분
- [ ] isExistReview - 존재 시 true
- [ ] isExistReview - 미존재 시 false
- [ ] requestBlockReview - 리뷰 차단 성공
- [ ] requestBlockReview - 존재하지 않는 리뷰 처리 명확화
- [ ] requestBlockReview - 이미 차단된 리뷰 멱등성
- [ ] getReviewInfo - 상세 정보 정확히 조회
- [ ] getReviewInfo - 존재하지 않는 리뷰 처리

### DefaultAlcoholFacade

- [ ] existsByAlcoholId - 술 존재 시 true 반환
- [ ] existsByAlcoholId - 술 미존재 시 false 반환
- [ ] isValidAlcoholId - 유효하지 않은 술 ID 시 예외
- [ ] findAlcoholInfoById - 술 정보 정확히 조회
- [ ] findAlcoholInfoById - 존재하지 않는 술 시 빈 Optional
- [ ] getAlcoholSummaryItemWithNext - 현재 술과 다음 술 정보 조회
- [ ] findAlcoholImageUrlById - 이미지 URL 정확히 조회

### FollowService ✅ 완료

- [x] updateFollowStatus - 신규 팔로우 생성
- [x] updateFollowStatus - 팔로우 상태 변경
- [x] updateFollowStatus - 자기 자신 팔로우 예외
- [x] updateFollowStatus - 현재 유저 없음 예외
- [x] updateFollowStatus - 타겟 유저 없음 예외
- [x] updateFollowStatus - 중복 팔로우 멱등성
- [x] InMemoryFollowRepository 구현 완료

### InMemory 구현체 생성 ✅ 완료

- [x] InMemoryUserQueryRepository.java 이동 완료
- [x] InMemoryReviewRepository.java 이동 완료
- [x] InMemoryAlcoholQueryRepository.java 이동 완료
- [x] InMemoryFollowRepository.java 생성 완료

### 테스트 파일 생성 ✅ 완료

- [x] DefaultUserFacadeTest.java 생성 완료 (8개 테스트)
- [x] DefaultReviewFacadeTest.java 생성 완료 (8개 테스트)
- [x] DefaultAlcoholFacadeTest.java 생성 완료 (7개 테스트)
- [x] FollowServiceTest.java 생성 완료 (7개 테스트)
