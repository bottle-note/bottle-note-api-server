# Facade 계층 테스트 커버리지

## 0. 왜 Facade 테스트인가

### Facade의 역할

Facade는 DDD 아키텍처에서 도메인 간 조율자 역할을 수행합니다:
- 여러 Service를 조합하여 복합적인 비즈니스 로직 구현
- 도메인 간 경계를 넘나드는 트랜잭션 관리
- Controller와 Service 사이의 계약 정의

### Facade 테스트가 중요한 이유

**도메인 간 계약의 검증**

Facade는 여러 도메인 Service를 조합합니다. Facade 테스트 없이는 이 조합이 올바른지 알 수 없습니다.
- ReviewFacade가 UserFacade를 올바르게 호출하는가?
- 트랜잭션 경계가 정확한가?
- 예외 전파가 의도대로 동작하는가?

**실제 버그가 숨어있는 곳**

단순해 보이는 Facade 코드에도 버그가 있습니다:

```java
public void requestBlockReview(Long reviewId) {
    reviewRepository.findById(reviewId).ifPresent(Review::blockReview);
}
```

이 코드는 존재하지 않는 리뷰를 차단하려 해도 조용히 무시합니다.
이것이 의도인가? 버그인가? 테스트 없이는 알 수 없습니다.

**리팩토링의 안전망**

Service 내부를 수정해도 Facade 테스트가 통과하면 외부 계약이 보존됨을 보장합니다.
이는 Service 리팩토링에 대한 자신감을 제공합니다.

**신입 개발자를 위한 문서**

"이 Facade는 어떻게 사용하나요?"
테스트 코드를 보면 모든 사용 시나리오를 이해할 수 있습니다.

## 1. 현황 분석

### 전체 Facade 목록

| Facade | 위치 | 메서드 수 | 테스트 상태 |
|--------|------|-----------|------------|
| DefaultUserFacade | bottlenote-mono/src/main/java/app/bottlenote/user/service/ | 3 | 0% |
| DefaultReviewFacade | bottlenote-mono/src/main/java/app/bottlenote/review/service/ | 5 | 0% |
| DefaultAlcoholFacade | bottlenote-mono/src/main/java/app/bottlenote/alcohols/service/ | 2 | 0% |
| ~~FollowService~~ | bottlenote-mono/src/main/java/app/bottlenote/user/service/ | 다수 | **제외** |

### 커버리지 현황

- 전체 Facade: 4개
- 단위 테스트 대상: 3개 (FollowService 제외)
- 테스트 존재: 0개
- **현재 커버리지: 0%**
- **목표 커버리지: 85%**

### FollowService 제외 사유

**FollowService는 InMemory 단위 테스트에서 제외합니다.**

**기술적 이유:**
- FollowRepository는 `JpaRepository<Follow, Long>` 상속
- JpaRepository는 약 20개의 기본 메서드 자동 제공
- InMemory 구현 시 모든 JPA 메서드 구현 필요 (비현실적)
- `@Query` JPQL 쿼리는 InMemory 환경에서 실행 불가

**우선순위 판단:**
- FollowService는 P1(중요) 등급으로 P0(최우선)이 아님
- DefaultUserFacade, DefaultReviewFacade가 더 핵심적
- 빠르게 핵심 Facade 커버리지 확보가 우선

**향후 계획:**
- FollowService는 별도의 통합 테스트(TestContainers)로 작성 예정
- 또는 API 모듈의 통합 테스트로 간접 검증

### 목표 설정 근거

**왜 85%인가?**
- 업계 표준: 핵심 계층은 85-95% 권장 (Google: 90% = exemplary)
- Facade는 도메인 간 계약의 핵심이므로 높은 커버리지 필요
- 하지만 일부 예외 경로는 통합 테스트로 대체 가능
- 100%는 과도한 목표 (시간 대비 효율 감소, Martin Fowler 경고)

자세한 근거는 `0-개요.md`의 "커버리지 표준 및 근거" 참조

### 왜 0%인가?

Facade 계층은 프로젝트에서 비교적 최근에 도입된 패턴입니다.
초기에는 Service 테스트에 집중하면서 Facade 테스트가 누락되었습니다.
하지만 Facade는 도메인 간 계약의 핵심이므로 테스트가 필수적입니다.

## 2. 우선순위

### P0: 최우선 작성 대상

**DefaultReviewFacade**
- 이유: 차단 로직에 잠재적 버그 존재 (ifPresent 사용)
- 영향도: Review 도메인 전체에 영향
- 복잡도: 중간 (5개 메서드)

**DefaultUserFacade**
- 이유: 전체 도메인에서 사용되는 핵심 Facade
- 영향도: 모든 도메인에서 사용자 검증 시 호출
- 복잡도: 낮음 (3개 메서드)

### P1: 중요 작성 대상

**DefaultAlcoholFacade**
- 이유: 주류 정보 조회의 중심
- 영향도: Review, Rating 등 다수 도메인과 연계
- 복잡도: 낮음 (2개 메서드)

**~~FollowService~~ (제외)**
- 제외 이유: JpaRepository 상속으로 InMemory 구현 불가
- 향후 계획: 별도 통합 테스트로 작성 예정

## 3. 구체적 테스트 시나리오

### DefaultUserFacade

**파일 위치**: `bottlenote-mono/src/main/java/app/bottlenote/user/service/DefaultUserFacade.java`

#### 메서드: existsByUserId

**시나리오 1: 유저가 존재할 때**
- 시나리오: 유저가 존재할 때 true를 반환해야 한다
- 왜: 기본 동작 검증, 다른 도메인에서 의존하는 핵심 기능
- 테스트 방법: 유저 저장 후 existsByUserId 호출

**시나리오 2: 유저가 존재하지 않을 때**
- 시나리오: 유저가 존재하지 않을 때 false를 반환해야 한다
- 왜: 존재하지 않는 경우 처리 검증
- 테스트 방법: 저장하지 않은 ID로 existsByUserId 호출

#### 메서드: isValidUserId

**시나리오 1: 유효한 유저일 때**
- 시나리오: 유효한 유저 ID일 때 예외가 발생하지 않아야 한다
- 왜: 정상 케이스 검증
- 테스트 방법: 유저 저장 후 isValidUserId 호출, 예외 없음 확인

**시나리오 2: 유효하지 않은 유저일 때**
- 시나리오: 유효하지 않은 유저 ID일 때 USER_NOT_FOUND 예외가 발생해야 한다
- 왜: 예외 처리 검증, 잘못된 ID 요청 방어
- 테스트 방법: 존재하지 않는 ID로 호출, UserException 발생 확인

**시나리오 3: null ID일 때**
- 시나리오: null 유저 ID일 때 적절한 예외가 발생해야 한다
- 왜: null 안전성 검증
- 테스트 방법: null로 호출, 예외 발생 확인

#### 메서드: getUserProfileInfo

**시나리오 1: 유저 프로필 조회 성공**
- 시나리오: 유저가 존재할 때 프로필 정보를 정확히 반환해야 한다
- 왜: 정상 케이스 및 데이터 매핑 검증
- 테스트 방법: 유저 저장 후 getUserProfileInfo 호출, 모든 필드 검증

**시나리오 2: 존재하지 않는 유저 조회**
- 시나리오: 존재하지 않는 유저일 때 USER_NOT_FOUND 예외가 발생해야 한다
- 왜: 예외 처리 검증
- 테스트 방법: 존재하지 않는 ID로 호출, 예외 확인

**시나리오 3: 여러 유저의 프로필 구분**
- 시나리오: 서로 다른 유저의 프로필을 정확히 구분해야 한다
- 왜: 데이터 정확성 검증
- 테스트 방법: 여러 유저 저장 후 각각 조회, 올바른 정보 반환 확인

### DefaultReviewFacade

**파일 위치**: `bottlenote-mono/src/main/java/app/bottlenote/review/service/DefaultReviewFacade.java`

#### 메서드: getReviewInfoList

**시나리오 1: 리뷰 목록 조회 성공**
- 시나리오: 술 ID로 리뷰 목록을 조회할 때 정확한 목록을 반환해야 한다
- 왜: 핵심 조회 기능 검증
- 테스트 방법: 리뷰 저장 후 getReviewInfoList 호출, 결과 확인

**시나리오 2: 리뷰가 없을 때**
- 시나리오: 리뷰가 없는 술 ID로 조회할 때 빈 목록을 반환해야 한다
- 왜: 엣지 케이스 검증
- 테스트 방법: 리뷰 없는 술 ID로 호출, 빈 목록 확인

**시나리오 3: 페이징 처리**
- 시나리오: 페이지 크기만큼만 리뷰를 반환해야 한다
- 왜: 페이징 로직 검증
- 테스트 방법: 다수 리뷰 저장 후 pageSize=6 확인

#### 메서드: getAlcoholIdByReviewId

**시나리오 1: 정상 조회**
- 시나리오: 리뷰 ID로 술 ID를 정확히 조회해야 한다
- 왜: 기본 동작 검증
- 테스트 방법: 리뷰 저장 후 getAlcoholIdByReviewId 호출, 술 ID 일치 확인

**시나리오 2: 존재하지 않는 리뷰**
- 시나리오: 존재하지 않는 리뷰 ID일 때 REVIEW_NOT_FOUND 예외가 발생해야 한다
- 왜: 예외 처리 검증
- 테스트 방법: 존재하지 않는 ID로 호출, 예외 확인

**시나리오 3: 여러 리뷰 구분**
- 시나리오: 서로 다른 리뷰는 서로 다른 술 ID를 반환해야 한다
- 왜: 데이터 정확성 검증
- 테스트 방법: 여러 리뷰 저장 후 각각 조회, 올바른 술 ID 확인

#### 메서드: isExistReview

**시나리오 1: 존재하는 리뷰**
- 시나리오: 리뷰가 존재할 때 true를 반환해야 한다
- 왜: 기본 동작 검증
- 테스트 방법: 리뷰 저장 후 isExistReview 호출, true 확인

**시나리오 2: 존재하지 않는 리뷰**
- 시나리오: 리뷰가 존재하지 않을 때 false를 반환해야 한다
- 왜: 존재하지 않는 경우 처리 검증
- 테스트 방법: 저장하지 않은 ID로 호출, false 확인

#### 메서드: requestBlockReview

**시나리오 1: 리뷰 차단 성공**
- 시나리오: 리뷰가 존재할 때 정상적으로 차단해야 한다
- 왜: 핵심 기능 검증
- 테스트 방법: 리뷰 저장 후 requestBlockReview 호출, 차단 상태 확인

**시나리오 2: 존재하지 않는 리뷰 차단 시도 (중요!)**
- 시나리오: 존재하지 않는 리뷰를 차단할 때의 동작을 명확히 해야 한다
- 왜: 현재 ifPresent로 인해 조용히 무시되는데, 이것이 의도인지 확인 필요
- 테스트 방법: 존재하지 않는 ID로 호출, 동작 확인
- 참고: 예외를 던지는 것이 더 명확할 수 있음

**시나리오 3: 이미 차단된 리뷰 재차단**
- 시나리오: 이미 차단된 리뷰를 다시 차단할 때 멱등성을 보장해야 한다
- 왜: 중복 요청 처리 검증
- 테스트 방법: 차단 후 재차단 호출, 여전히 차단 상태 확인

#### 메서드: getReviewInfo

**시나리오 1: 리뷰 상세 조회 성공**
- 시나리오: 리뷰 ID로 상세 정보를 정확히 조회해야 한다
- 왜: 핵심 조회 기능 검증
- 테스트 방법: 리뷰 저장 후 getReviewInfo 호출, 모든 필드 확인

**시나리오 2: 존재하지 않는 리뷰 조회**
- 시나리오: 존재하지 않는 리뷰 ID일 때 적절한 처리를 해야 한다
- 왜: 예외 케이스 검증
- 테스트 방법: 존재하지 않는 ID로 호출, 동작 확인

### DefaultAlcoholFacade

**파일 위치**: `bottlenote-mono/src/main/java/app/bottlenote/alcohols/service/DefaultAlcoholFacade.java`

#### 메서드별 시나리오

**getReviewInfoList**
- 시나리오 1: 술 ID로 리뷰 목록을 조회할 때 정확한 목록을 반환해야 한다
- 시나리오 2: 리뷰가 없을 때 빈 목록을 반환해야 한다
- 시나리오 3: 페이지 크기 제한이 적용되어야 한다

**getAlcoholName**
- 시나리오 1: 술 ID로 술 이름을 정확히 조회해야 한다
- 시나리오 2: 존재하지 않는 술 ID일 때 예외가 발생해야 한다

### ~~FollowService~~ (제외)

**제외 사유**: JpaRepository 상속으로 InMemory 단위 테스트 불가

InMemory 구현이 불가능하므로 이번 단위 테스트에서는 제외합니다.
향후 TestContainers를 사용한 통합 테스트로 작성 예정입니다.

## 4. 체크리스트

### DefaultUserFacade

- [ ] existsByUserId - 유저 존재 시 true 반환
- [ ] existsByUserId - 유저 미존재 시 false 반환
- [ ] isValidUserId - 유효한 유저 시 예외 없음
- [ ] isValidUserId - 유효하지 않은 유저 시 USER_NOT_FOUND 예외
- [ ] isValidUserId - null ID 시 예외 발생
- [ ] getUserProfileInfo - 프로필 정확히 반환
- [ ] getUserProfileInfo - 존재하지 않는 유저 시 예외
- [ ] getUserProfileInfo - 여러 유저 구분

### DefaultReviewFacade

- [ ] getReviewInfoList - 리뷰 목록 정확히 조회
- [ ] getReviewInfoList - 리뷰 없을 때 빈 목록
- [ ] getReviewInfoList - 페이징 처리
- [ ] getAlcoholIdByReviewId - 술 ID 정확히 조회
- [ ] getAlcoholIdByReviewId - 존재하지 않는 리뷰 시 예외
- [ ] getAlcoholIdByReviewId - 여러 리뷰 구분
- [ ] isExistReview - 존재 시 true
- [ ] isExistReview - 미존재 시 false
- [ ] requestBlockReview - 리뷰 차단 성공
- [ ] requestBlockReview - 존재하지 않는 리뷰 처리 명확화
- [ ] requestBlockReview - 이미 차단된 리뷰 멱등성
- [ ] getReviewInfo - 상세 정보 정확히 조회
- [ ] getReviewInfo - 존재하지 않는 리뷰 처리

### DefaultAlcoholFacade

- [ ] existsByAlcoholId - 술 존재 시 true 반환
- [ ] existsByAlcoholId - 술 미존재 시 false 반환
- [ ] isValidAlcoholId - 유효하지 않은 술 ID 시 예외
- [ ] findAlcoholInfoById - 술 정보 정확히 조회
- [ ] findAlcoholInfoById - 존재하지 않는 술 시 빈 Optional
- [ ] getAlcoholSummaryItemWithNext - 현재 술과 다음 술 정보 조회
- [ ] findAlcoholImageUrlById - 이미지 URL 정확히 조회

### ~~FollowService~~ (제외)

InMemory 구현 불가로 단위 테스트 제외.
향후 통합 테스트로 작성 예정.

### InMemory 구현체 생성

- [ ] InMemoryUserQueryRepository.java 이동
- [ ] InMemoryReviewRepository.java 이동
- [ ] InMemoryAlcoholQueryRepository.java 이동

### 테스트 파일 생성

- [ ] DefaultUserFacadeTest.java 생성 (8개 테스트)
- [ ] DefaultReviewFacadeTest.java 생성 (8개 테스트)
- [ ] DefaultAlcoholFacadeTest.java 생성 (7개 테스트)
